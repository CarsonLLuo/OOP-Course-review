# Week10

# git init

​`git init`​是Git中的命令，用于在当前目录下创建一个新的空白Git仓库。

当我们开始一个新的项目或者想要对现有项目应用版本控制时，我们可以使用`git init`​命令在项目的根目录执行，以初始化一个新的Git仓库。执行`git init`​命令后，Git会在当前目录下创建一个名为`.git`​的子目录，该目录包含了Git所需的所有版本控制相关的文件和目录。

初始化Git仓库后，我们可以使用其他Git命令来进行版本控制，如添加文件、提交修改、创建分支等。

需要注意的是，执行`git init`​命令后，Git仓库会被创建在当前目录以及其所有子目录中。如果想要在指定的目录下创建Git仓库，可以在执行`git init`​时提供相应的目录路径参数，如`git init <目录路径>`​。

值得注意的是，`git init`​只需在新项目的开始阶段执行一次，用于初始化Git仓库。对于已经存在的Git仓库，不需要重复执行该命令。

# git clone

​`git clone https://github.com/me/myproject`​是Git中的命令，用于克隆（Clone）远程代码仓库到本地。

执行该命令后，Git会在当前目录下创建一个名为`myproject`​的文件夹，并将远程代码仓库`https://github.com/me/myproject`​中的所有代码、版本历史和分支信息复制到本地的`myproject`​文件夹中。

克隆一个远程代码仓库是获取远程代码库的一种常见方式，它使我们能够在本地进行开发、修改和提交代码，并与远程仓库进行同步和交互。

需要注意的是，执行`git clone`​命令时，会默认将远程代码仓库的整个历史记录复制到本地，包括所有分支和标签。克隆完成后，我们可以在本地进行代码的修改、提交和其他操作，然后使用Git的其他命令将修改的代码推送（Push）回远程仓库。

在执行`git clone`​命令时，还可以提供其他参数来进一步定制克隆行为，例如指定克隆的分支、限制克隆的历史记录数量等。

总结起来，`git clone`​命令是将远程代码仓库克隆到本地的操作，使我们能够获取代码并在本地进行开发和修改。

# git add

​`git add <文件名>`​是Git中的命令，用于将指定的文件或目录添加到暂存区（Staging Area）。该命令将修改的文件从工作区添加到暂存区，准备进行下一步的提交操作。

当我们对项目中的文件进行修改后，如果要将这些修改提交到代码仓库，需要经过两个步骤：将修改的文件添加到暂存区，然后将暂存区的文件提交到仓库。

使用`git add <文件名>`​命令，可以将指定的文件添加到暂存区。可以指定单个文件的文件名，也可以使用通配符`*`​来添加多个文件。例如：

* ​`git add file1.txt`​：将`file1.txt`​文件添加到暂存区。
* ​`git add *.txt`​：将所有扩展名为`.txt`​的文件添加到暂存区。
* ​`git add folder/`​：将名为`folder`​的目录下的所有文件添加到暂存区。

添加到暂存区后，可以使用`git status`​命令查看文件的状态，确认文件是否已经添加到暂存区。然后可以继续进行提交操作，将暂存区的文件修改提交到代码仓库。

# .gitignore

​`.gitignore`​是一个用于指定哪些文件或目录应该被Git忽略的配置文件。

在一个Git仓库中，`.gitignore`​文件可以放置在仓库的根目录或任何子目录中。它的作用是告诉Git哪些文件或目录不应该被纳入版本控制。

通常，我们会在`.gitignore`​文件中列出一些特定的文件、目录或文件类型，以指示Git忽略它们，不将其纳入版本控制。这样可以避免将一些不必要的或敏感的文件提交到代码仓库中，比如临时文件、日志文件、编译产生的文件、系统生成的文件等。

​`.gitignore`​文件中可以使用简单的通配符和模式来指定忽略的文件或目录。常见的模式包括：

* ​`*`​：匹配任意多个字符（除了路径分隔符）。
* ​`?`​：匹配任意一个字符（除了路径分隔符）。
* ​`/`​：用于指定路径分隔符。
* ​`**/`​：递归匹配任意子目录。
* ​`!`​：用于取消忽略规则，使某个文件或目录不被忽略。

​`.gitignore`​文件的格式非常简单，每一行代表一个忽略规则。可以使用`#`​符号开头添加注释。

例如，一个简单的`.gitignore`​文件可能如下所示：

```
# 忽略所有的.class文件
*.class

# 忽略build目录下的所有内容
/build/

# 不忽略build/scripts目录
!/build/scripts/

# 忽略.idea文件夹及其内容
.idea/
```

通过使用`.gitignore`​文件，我们可以更好地管理Git仓库中的文件和目录，确保只将需要的文件纳入版本控制，避免不必要的文件污染和冲突。

# git reset

​`git reset <HEAD> <FILENAME>`​ 是一个用于取消暂存文件的 Git 命令。

当你对文件进行修改并使用 `git add`​ 命令将其添加到暂存区（也称为索引）时，文件的更改被暂存以待提交。如果你在暂存文件后意识到不希望将该文件包含在下一次提交中，可以使用 `git reset <HEAD> <FILENAME>`​ 命令将文件从暂存区中移除。

其中，`<HEAD>`​ 表示当前的提交（最近一次的提交），`<FILENAME>`​ 表示要取消暂存的文件名。

执行 `git reset <HEAD> <FILENAME>`​ 后，Git 将取消对指定文件的暂存，并将其返回到未暂存的状态。这样，文件的更改将不会包含在下一次提交中。

需要注意的是，`git reset`​ 命令还有其他的使用方式，如 `git reset HEAD`​ 可以取消所有文件的暂存，或者使用 `git reset --hard <COMMIT>`​ 可以将当前分支重置到指定的提交。

请注意，`git reset`​ 命令的使用要谨慎，特别是在与其他命令（如 `git commit`​）结合使用时，以免造成不可逆的修改。建议在使用前先了解其具体的用法和效果，并在需要时备份重要的文件和提交。

# git rm

​`git rm --cached <filename>`​ 是一个用于从 Git 中移除文件但保留在本地工作目录的命令。

当你想要将某个文件从 Git 的版本控制中移除，但仍希望保留该文件在本地工作目录中时，可以使用 `git rm --cached <filename>`​ 命令。

其中，`<filename>`​ 表示要移除的文件名。

执行该命令后，Git 将从版本控制中移除指定的文件，但该文件仍会保留在本地工作目录中。这意味着该文件不再被 Git 跟踪，不会包含在下一次的提交中，但仍然存在于本地文件系统中。

需要注意的是，`git rm --cached`​ 命令只会影响 Git 的版本控制，不会删除实际的文件。如果你希望从本地文件系统中彻底删除该文件，可以使用 `git rm --cached <filename>`​ 后，再执行 `git commit`​ 提交更改。

请注意，在使用 `git rm --cached`​ 命令时要小心，确保只移除需要的文件，并在执行前先进行备份或确认。

# git对象类型

1. Blob（文件数据对象）：Blob 对象存储文件的内容。每个文件在 Git 中都被表示为一个 Blob 对象。
2. Tree（目录对象）：Tree 对象存储文件和目录的结构信息。它包含了一组指向 Blob 或其他 Tree 对象的指针，以及对应的文件名或目录名。
3. Commit（提交对象）：Commit 对象存储了一次代码提交的元数据，包括作者、提交时间、提交消息以及指向一个 Tree 对象的指针。每次代码提交都会创建一个新的 Commit 对象。
4. Tag（标签对象）：Tag 对象是一个指向某个 Commit 对象的静态引用，通常用于标记某个特定的版本或里程碑。标签对象包含了标签的名称、标签的创建者、创建时间以及对应的 Commit 对象的指针。
5. HEAD：HEAD 是一个指向当前活动分支或提交的符号引用。它指示了当前工作树中正在工作的分支或提交。通过 HEAD，Git 知道当前所处的状态和正在进行的操作。

‍

​`git commit --amend`​ 是一个用于修改最新一次提交的 Git 命令。

当你执行 `git commit --amend`​ 命令时，Git 将允许你修改最新一次提交的提交信息。它会打开文本编辑器，让你编辑提交信息，包括提交的说明和标题。你可以修改这些信息后保存并关闭编辑器，然后 Git 会将修改后的提交信息应用到最新的提交中。

除了修改提交信息，`git commit --amend`​ 也允许你对最新提交进行其他修改。你可以添加、修改或删除文件，然后重新提交以修改最新提交的内容。这对于纠正提交中的错误或添加遗漏的文件非常有用。

需要注意的是，`git commit --amend`​ 只应该在尚未推送或共享的提交上使用。如果你已经推送了提交或将其共享给其他人，修改最新提交可能会破坏协作和版本历史。因此，谨慎使用 `git commit --amend`​ 命令，并确保了解其影响。

‍

​`git reset HEAD~`​ 是一个用于撤销最新一次提交并将其修改的 Git 命令。

当你执行 `git reset HEAD~`​ 命令时，Git 将会将当前分支的 `HEAD`​ 指针和 `HEAD`​ 引用的父提交（即上一次提交）进行重置。这会将最新的提交从分支历史中移除，并将修改的内容放回工作区和暂存区。

通过执行 `git reset HEAD~`​，你可以撤销最新一次提交，但保留修改的文件和更改。这意味着你可以对上一次提交所包含的文件进行进一步的修改和调整，然后再次提交。

需要注意的是，`git reset HEAD~`​ 是一个潜在的危险操作，因为它会改变分支历史。如果你已经推送了该提交或与他人共享了该提交，那么执行 `git reset HEAD~`​ 可能会导致协作问题。因此，在执行此操作之前，请确保了解其影响，并确保在正确的上下文中使用它。

‍

​`git status`​ 是一个用于查看 Git 仓库当前状态的命令。

执行 `git status`​ 命令时，Git 会显示以下信息：

1. 分支信息：当前所在的分支和分支的状态。
2. 工作区状态：显示未暂存的修改和未跟踪的文件。
3. 暂存区状态：显示已暂存的修改和即将提交的文件。
4. 提示信息：根据仓库状态给出相应的提示和建议。

​`git status`​ 帮助你了解当前工作目录和暂存区的状态，以及下一步应该采取的操作。它可以帮助你判断是否需要提交修改、添加新文件、暂存文件或丢弃修改等。

通过频繁地使用 `git status`​ 命令，你可以跟踪仓库的变化并保持对代码状态的清晰认识。

‍

​`git log`​ 是一个用于查看 Git 提交历史记录的命令。

执行 `git log`​ 命令时，Git 会按照提交的时间顺序列出每个提交的信息，包括：

* 提交哈希值（commit hash）：每个提交都有一个唯一的哈希值，用于标识该提交。
* 作者和提交者：显示提交的作者和提交者的姓名和电子邮件地址。
* 提交日期：显示提交的日期和时间。
* 提交信息：开发人员在提交代码时提供的相关信息，描述了此次提交的目的和内容。

​`git log`​ 默认按照最新的提交显示，以最新的提交记录开始，然后按照时间顺序向后列出每个提交。你可以使用不同的选项来控制日志输出的格式和内容，例如限制日志的数量、显示详细的文件变更信息等。

通过查看 `git log`​ 的输出，你可以了解项目的历史记录、每个提交的详细信息以及它们之间的关系。这对于代码审查、跟踪 bug、查找特定功能的实现以及了解项目的演变非常有帮助。

‍

​`git checkout <reference>`​ 是一个用于切换到指定引用（reference）的命令。

引用可以是分支名、标签名、提交哈希值或其他可以唯一标识一个提交的标识符。

当你执行 `git checkout <reference>`​ 命令时，Git 将会将工作目录和索引更新为指定引用所指向的提交，并将当前分支指向该引用。这意味着你将切换到指定引用所在的分支或将进入一个"分离头指针"（detached HEAD）的状态。

切换到分支名或标签名时，你将进入该分支或标签的状态，并且任何后续的提交操作都将在该分支上进行。而切换到提交哈希值时，你将进入一个分离头指针的状态，这意味着你处于一个不与任何分支相关联的特定提交状态。在这种情况下，你可以查看和编辑代码，但新的提交不会属于任何分支，如果你进行新的提交，你需要保存该提交的哈希值以便后续操作。

​`git checkout`​ 命令还可以用于切换文件或目录到特定状态，通过提供文件或目录的路径作为 `<reference>`​ 参数来实现。这将撤销对指定文件或目录的更改，将其还原为 `<reference>`​ 引用的版本。

总之，`git checkout <reference>`​ 命令是一个用于切换到指定引用或还原文件/目录状态的重要命令，可以在不同的情况下帮助你导航和管理代码库中的不同状态和版本。

‍

​`git merge <name>`​ 是一个用于合并分支的命令。

它将当前分支与指定的 `<name>`​ 分支进行合并，将两个分支的修改内容合并到一起。合并操作会自动尝试将两个分支的修改进行合理的组合，但在某些情况下可能会发生冲突，需要手动解决。

合并操作通常在以下情况下使用：

* 将一个分支的修改合并到另一个分支，以将最新的更改引入到主分支或稳定分支中。
* 合并两个开发人员的工作，当两个人在不同的分支上进行开发，并且他们的工作已经独立进展到一定程度。

在执行 `git merge <name>`​ 命令之前，通常需要确保当前分支是你希望将其他分支合并到其中的分支。合并操作会将其他分支的提交记录应用到当前分支，并创建一个新的合并提交，将两个分支的修改整合在一起。

如果合并过程中发生冲突，Git 将会提示你解决冲突。你需要手动编辑冲突文件，解决冲突后再进行提交。

总结起来，`git merge <name>`​ 命令用于将指定分支的修改合并到当前分支，并创建一个新的合并提交。它是在合并分支和整合工作时非常有用的命令。

‍

​`git fetch <remote>`​ 是一个用于从远程仓库获取更新的命令。

在 Git 中，远程仓库是指位于远程服务器上的代码仓库，它可以与本地仓库进行交互。当你使用 `git fetch <remote>`​ 命令时，Git 会连接到指定的远程仓库并获取远程仓库中的最新提交和分支信息，但不会将这些更新直接应用到当前工作目录中。

​`<remote>`​ 是远程仓库的名称，通常为 "origin"，它是 Git 默认给定的远程仓库名称。

使用 `git fetch <remote>`​ 命令后，你可以通过查看远程分支的状态来了解远程仓库的最新更新情况，包括新的提交和分支。此时，这些更新还没有合并到本地分支上，需要进一步处理才能将它们整合到本地工作目录中。

与 `git pull`​ 命令不同，`git fetch`​ 只是获取远程仓库的更新信息，而不会自动合并或更新你的当前分支。这使得你可以在获取更新后进行代码审查或其他操作，然后再决定如何处理这些更新。

总结起来，`git fetch <remote>`​ 命令用于从指定的远程仓库获取最新的提交和分支信息，但不会自动应用到当前分支。它是与远程仓库进行交互并获取更新的常用命令。

‍

‍
